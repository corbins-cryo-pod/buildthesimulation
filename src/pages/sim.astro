---
import Layout from "../layouts/Layout.astro";
---

<Layout
  pageTitle="Simulation"
  subtitle="Peripheral nerve cross-section sandbox (v0). Grid axons + stimulation + recording."
  description="Interactive peripheral nerve cross-section sandbox for exploring electrode geometry, stimulation, and simple recording readouts."
>
  <section class="simShell">
    <aside class="panel" aria-label="Controls">
      <div class="panelSection">
        <div class="panelTitle">Library</div>
        <div class="row">
          <button class="btn" id="addCuff">Add cuff</button>
          <button class="btn" id="addIntra">Add intrafascicular</button>
        </div>
        <div class="row">
          <button class="btn ghost" id="reset">Reset</button>
        </div>
      </div>

      <div class="panelSection">
        <div class="panelTitle">Geometry</div>

        <label class="lab">
          Axon sites (count)
          <div class="rangeRow">
            <input id="axonCount" type="range" min="0" max="6000" value="2200" />
            <div class="rangeMeta">
              <span id="axonCountVal"></span>
              <span class="rangeMinMax">min <span id="axonCountMin"></span> / max <span id="axonCountMax"></span></span>
            </div>
          </div>
        </label>

        <p class="muted">
          Nerve diameter is fixed at <b>2.0 mm</b>. Axons are rendered as non-overlapping grid “sites”
          (conceptually ~10 µm each, visually exaggerated).
        </p>
      </div>

      <div class="panelSection">
        <div class="panelTitle">Stimulation</div>

        <label class="lab">
          Stim amplitude (a.u.)
          <div class="rangeRow">
            <input id="stimAmp" type="range" min="0" max="100" value="40" />
            <div class="rangeMeta">
              <span id="stimAmpVal"></span>
              <span class="rangeMinMax">min <span id="stimAmpMin"></span> / max <span id="stimAmpMax"></span></span>
            </div>
          </div>
        </label>

        <label class="lab">
          Field falloff
          <div class="rangeRow">
            <input id="falloff" type="range" min="5" max="60" value="24" />
            <div class="rangeMeta">
              <span id="falloffVal"></span>
              <span class="rangeMinMax">min <span id="falloffMin"></span> / max <span id="falloffMax"></span></span>
            </div>
          </div>
        </label>

        <label class="lab">
          Threshold (proxy)
          <div class="rangeRow">
            <input id="thresh" type="range" min="0" max="200" value="55" />
            <div class="rangeMeta">
              <span id="threshVal"></span>
              <span class="rangeMinMax">min <span id="threshMin"></span> / max <span id="threshMax"></span></span>
            </div>
          </div>
        </label>

        <div class="row">
          <button class="btn" id="pulse">Pulse</button>
          <button class="btn ghost" id="stop">Stop</button>
        </div>

        <label class="lab">
          Waveform
          <select id="wave">
            <option value="monophasic">Monophasic square</option>
            <option value="biphasic">Biphasic square</option>
            <option value="sine">Sine</option>
          </select>
        </label>

        <label class="lab">
          Frequency (Hz)
          <div class="rangeRow">
            <input id="freq" type="range" min="1" max="200" value="20" />
            <div class="rangeMeta">
              <span id="freqVal"></span>
              <span class="rangeMinMax">min <span id="freqMin"></span> / max <span id="freqMax"></span></span>
            </div>
          </div>
        </label>

        <label class="lab">
          Pulse width (ms)
          <div class="rangeRow">
            <input id="pw" type="range" min="1" max="25" value="5" />
            <div class="rangeMeta">
              <span id="pwVal"></span>
              <span class="rangeMinMax">min <span id="pwMin"></span> / max <span id="pwMax"></span></span>
            </div>
          </div>
        </label>

        <label class="lab">
          Train duration (ms)
          <div class="rangeRow">
            <input id="dur" type="range" min="50" max="1500" value="450" />
            <div class="rangeMeta">
              <span id="durVal"></span>
              <span class="rangeMinMax">min <span id="durMin"></span> / max <span id="durMax"></span></span>
            </div>
          </div>
        </label>
      </div>

      <div class="panelSection">
        <div class="panelTitle">View</div>
        <div class="row">
          <button class="btn ghost" id="viewReset">Reset view</button>
        </div>
        <p class="muted">
          Scroll to zoom. Drag empty space to pan. Drag electrodes to move them.
        </p>
      </div>

      <div class="panelSection">
        <div class="panelTitle">Selection</div>
        <div class="kv"><span>Type</span><span id="selType">—</span></div>
        <div class="kv"><span>ID</span><span id="selId">—</span></div>
        <div class="kv"><span>X</span><span id="selX">—</span></div>
        <div class="kv"><span>Y</span><span id="selY">—</span></div>

        <div class="row">
          <button class="btn" id="export">Export JSON</button>
          <button class="btn" id="import">Import JSON</button>
        </div>
      </div>

      <details class="panelSection" open>
        <summary class="panelTitle">Notes</summary>
        <p class="muted">
          Recording is a simplified distance-weighted spike detector. Axons “flicker” as slow Poisson noise
          and stimulation forces axons ON inside the thresholded field.
        </p>
      </details>
    </aside>

    <main class="stage" aria-label="Simulation canvas">
      <div class="stageBar">
        <div class="stageTitle">Peripheral nerve cross-section</div>
        <div class="stageHint">Zoom/pan + stimulation + recording (10 s window)</div>
      </div>

      <div class="stageBody">
        <canvas id="cnv" width="980" height="520"></canvas>

        <div class="recBar">
          <div class="recTitle">Recording</div>
          <div class="recHint">t=0 at 75% width • 10 s window • spikes weighted by distance to electrode</div>
        </div>
        <canvas id="rec" width="980" height="160"></canvas>
      </div>

      <div class="toast" id="toast" hidden></div>
    </main>
  </section>

  <dialog id="dlg" class="dlg">
    <form method="dialog" class="dlgInner">
      <div class="dlgHead">
        <div class="dlgTitle" id="dlgTitle">Export</div>
        <button class="btn ghost" value="cancel">Close</button>
      </div>
      <textarea id="dlgText" spellcheck="false"></textarea>
      <menu class="dlgActions">
        <button class="btn" id="dlgCopy" value="copy">Copy</button>
        <button class="btn" id="dlgApply" value="apply">Apply</button>
      </menu>
    </form>
  </dialog>
</Layout>

<script is:inline>
  const $ = (id) => document.getElementById(id);

  const cnv = $("cnv");
  const ctx = cnv.getContext("2d");

  const rec = $("rec");
  const rctx = rec.getContext("2d");

  const ui = {
    addCuff: $("addCuff"),
    addIntra: $("addIntra"),
    reset: $("reset"),
    export: $("export"),
    import: $("import"),

    stimAmp: $("stimAmp"),
    falloff: $("falloff"),
    thresh: $("thresh"),

    pulse: $("pulse"),
    stop: $("stop"),
    wave: $("wave"),
    freq: $("freq"),
    pw: $("pw"),
    dur: $("dur"),

    axonCount: $("axonCount"),

    viewReset: $("viewReset"),

    selType: $("selType"),
    selId: $("selId"),
    selX: $("selX"),
    selY: $("selY"),

    dlg: $("dlg"),
    dlgTitle: $("dlgTitle"),
    dlgText: $("dlgText"),
    dlgCopy: $("dlgCopy"),
    dlgApply: $("dlgApply"),
    toast: $("toast"),
  };

  // value labels
  const valIds = [
    ["axonCount", "axonCountVal", "axonCountMin", "axonCountMax"],
    ["stimAmp", "stimAmpVal", "stimAmpMin", "stimAmpMax"],
    ["falloff", "falloffVal", "falloffMin", "falloffMax"],
    ["thresh", "threshVal", "threshMin", "threshMax"],
    ["freq", "freqVal", "freqMin", "freqMax"],
    ["pw", "pwVal", "pwMin", "pwMax"],
    ["dur", "durVal", "durMin", "durMax"],
  ];

  function syncRangeMeta() {
    for (const [rid, vid, minId, maxId] of valIds) {
      const el = $(rid);
      if (!el) continue;
      $(vid).textContent = el.value;
      $(minId).textContent = el.min;
      $(maxId).textContent = el.max;
    }
  }

  function toast(msg) {
    ui.toast.textContent = msg;
    ui.toast.hidden = false;
    clearTimeout(toast._t);
    toast._t = setTimeout(() => (ui.toast.hidden = true), 1200);
  }

  function mkId() {
    return Math.random().toString(16).slice(2, 8);
  }
  function rand() {
    return Math.random();
  }

  // --- Constants / scale ---
  const NERVE_DIAMETER_MM = 2.0; // fixed
  const NERVE_DIAMETER_UM = NERVE_DIAMETER_MM * 1000;

  // Conceptual “axon site” size (~10 µm). We render as a square pixel (visually exaggerated).
  const AXON_SITE_UM = 10;

  // Noise firing (Poisson) — NOTE: using 100ms mean ISI to keep browser sane.
  // If you *really* want 100µs: set MEAN_ISI_S = 0.0001 (expect performance death).
  const MEAN_ISI_S = 0.10;
  const ON_DWELL_S = 0.030; // how long an axon stays black after a “fire” (visual)
  const STIM_DWELL_S = 0.10; // how long stimulation forces on (minimum)

  // Recording window: 10s total, with "now" at 75% width (7.5s past, 2.5s future)
  const REC_WINDOW_S = 10.0;
  const REC_NOW_X = 0.75; // 75%

  // Recording pickup distance model
  const PICKUP_STRONG_UM = 50;
  const PICKUP_ZERO_UM = 200;

  // --- Geometry helpers ---
  function randomInCircle(cx, cy, r) {
    const t = 2 * Math.PI * rand();
    const u = rand() + rand();
    const rr = u > 1 ? 2 - u : u;
    return { x: cx + Math.cos(t) * rr * r, y: cy + Math.sin(t) * rr * r };
  }

  function buildFascicles(nerve) {
    // Large fascicles that occupy most of the nerve, clover-like.
    // We intentionally oversize then gently push/clip.
    const { cx, cy, r } = nerve;

    const fr = r * 0.43;
    const d = r * 0.38;

    const fasc = [
      { x: cx - d, y: cy - d * 0.25, r: fr },
      { x: cx + d, y: cy - d * 0.25, r: fr * 0.97 },
      { x: cx - d * 0.10, y: cy + d * 0.95, r: fr * 0.96 },
      { x: cx + d * 0.20, y: cy + d * 0.95, r: fr * 0.93 },
    ];

    // push apart if needed
    for (let iter = 0; iter < 80; iter++) {
      let moved = false;

      for (let i = 0; i < fasc.length; i++) {
        for (let j = i + 1; j < fasc.length; j++) {
          const a = fasc[i], b = fasc[j];
          const dx = b.x - a.x;
          const dy = b.y - a.y;
          const dist = Math.hypot(dx, dy) || 1;
          const minDist = a.r + b.r + 10;
          if (dist < minDist) {
            const push = (minDist - dist) / 2;
            const ux = dx / dist;
            const uy = dy / dist;
            a.x -= ux * push;
            a.y -= uy * push;
            b.x += ux * push;
            b.y += uy * push;
            moved = true;
          }
        }
      }

      // keep inside nerve
      for (const f of fasc) {
        const dx = f.x - cx;
        const dy = f.y - cy;
        const dist = Math.hypot(dx, dy) || 1;
        const maxDist = r - f.r - 10;
        if (dist > maxDist) {
          f.x = cx + (dx / dist) * maxDist;
          f.y = cy + (dy / dist) * maxDist;
          moved = true;
        }
      }

      if (!moved) break;
    }

    return fasc;
  }

  // --- Axon sites (grid, non-overlapping) ---
  function buildAxonSites(nerve, fascicles, targetCount) {
    const { cx, cy, r } = nerve;

    // Grid spacing in world px: choose something readable
    // (this is visual; real units handled separately via umPerPx)
    const gridStepPx = 3; // smaller = denser

    // generate candidate grid points inside fascicles
    const candidates = [];
    const minX = Math.floor((cx - r) / gridStepPx) * gridStepPx;
    const maxX = Math.ceil((cx + r) / gridStepPx) * gridStepPx;
    const minY = Math.floor((cy - r) / gridStepPx) * gridStepPx;
    const maxY = Math.ceil((cy + r) / gridStepPx) * gridStepPx;

    for (let y = minY; y <= maxY; y += gridStepPx) {
      for (let x = minX; x <= maxX; x += gridStepPx) {
        // inside nerve
        if (Math.hypot(x - cx, y - cy) > r - 2) continue;

        // inside any fascicle
        let fid = -1;
        for (let i = 0; i < fascicles.length; i++) {
          const f = fascicles[i];
          if (Math.hypot(x - f.x, y - f.y) <= f.r - 2) {
            fid = i;
            break;
          }
        }
        if (fid < 0) continue;

        candidates.push({ x, y, fascicleId: fid });
      }
    }

    // Shuffle candidates (Fisher–Yates)
    for (let i = candidates.length - 1; i > 0; i--) {
      const j = Math.floor(rand() * (i + 1));
      [candidates[i], candidates[j]] = [candidates[j], candidates[i]];
    }

    const count = Math.min(targetCount, candidates.length);
    const axons = [];
    const now = performance.now() / 1000;

    function expSample(mean) {
      // exponential distribution
      return -Math.log(1 - rand()) * mean;
    }

    for (let i = 0; i < count; i++) {
      const c = candidates[i];
      axons.push({
        x: c.x,
        y: c.y,
        fascicleId: c.fascicleId,
        onUntil: 0,
        stimUntil: 0,
        nextFire: now + expSample(MEAN_ISI_S),
      });
    }

    return axons;
  }

  function defaultModel() {
    const W = cnv.width;
    const H = cnv.height;

    const nerve = {
      cx: W * 0.58,
      cy: H * 0.52,
      r: Math.min(W, H) * 0.33,
    };

    const fascicles = buildFascicles(nerve);

    const scale = {
      nerveDiameterMm: NERVE_DIAMETER_MM,
      axonCount: 2200,
    };

    const axons = buildAxonSites(nerve, fascicles, scale.axonCount);

    return {
      nerve,
      fascicles,
      axons,
      electrodes: [],
      stim: { amp: 40, falloff: 24, thresh: 55 },
      wave: { kind: "monophasic", freqHz: 20, pwMs: 5, durMs: 450 },
      pulse: { active: false, t0: 0 },

      // view
      view: { s: 1, ox: 0, oy: 0 },

      selectedId: null,

      // recording events: {t, amp}
      recEvents: [],
      recLastUpdate: performance.now() / 1000,
    };
  }

  let model = defaultModel();

  function umPerPx() {
    // nerve diameter in px is 2r
    return NERVE_DIAMETER_UM / (model.nerve.r * 2);
  }

  function worldFromScreen(evt) {
    const rect = cnv.getBoundingClientRect();
    const sx = ((evt.clientX - rect.left) / rect.width) * cnv.width;
    const sy = ((evt.clientY - rect.top) / rect.height) * cnv.height;
    const { s, ox, oy } = model.view;
    return { x: (sx - ox) / s, y: (sy - oy) / s };
  }

  function hitTest(x, y) {
    for (let i = model.electrodes.length - 1; i >= 0; i--) {
      const e = model.electrodes[i];
      if (e.type === "cuff") {
        const dx = x - model.nerve.cx;
        const dy = y - model.nerve.cy;
        const d = Math.hypot(dx, dy);
        if (Math.abs(d - e.r) < 10) return e;
      } else {
        const dx = x - e.x;
        const dy = y - e.y;
        if (Math.hypot(dx, dy) < 10) return e;
      }
    }
    return null;
  }

  function setSelected(id) {
    model.selectedId = id;
    const e = model.electrodes.find((q) => q.id === id);
    ui.selType.textContent = e ? e.type : "—";
    ui.selId.textContent = e ? e.id : "—";
    ui.selX.textContent = e ? Math.round(e.x ?? model.nerve.cx) : "—";
    ui.selY.textContent = e ? Math.round(e.y ?? model.nerve.cy) : "—";
  }

  function clampToNerve(e) {
    if (e.type !== "intra") return;
    const dx = e.x - model.nerve.cx;
    const dy = e.y - model.nerve.cy;
    const d = Math.hypot(dx, dy) || 1;
    const maxD = model.nerve.r * 0.92;
    if (d > maxD) {
      e.x = model.nerve.cx + (dx / d) * maxD;
      e.y = model.nerve.cy + (dy / d) * maxD;
    }
  }

  function stimMultiplier(nowMs) {
    if (!model.pulse.active) return 1;
    const t = (nowMs - model.pulse.t0) / 1000;
    const dur = model.wave.durMs / 1000;
    if (t < 0 || t > dur) return 0;

    const f = model.wave.freqHz;
    const pw = model.wave.pwMs / 1000;
    const phase = (t * f) % 1;

    if (model.wave.kind === "sine") {
      return Math.max(0, Math.sin(2 * Math.PI * f * t));
    }

    if (model.wave.kind === "biphasic") {
      const on1 = phase < pw * f;
      const on2 = phase >= 0.5 && phase < 0.5 + pw * f;
      return on1 ? 1 : on2 ? -1 : 0;
    }

    return phase < pw * f ? 1 : 0;
  }

  function fieldAt(x, y, mult = 1) {
    const fall = Number(model.stim.falloff);
    const amp = Number(model.stim.amp) * mult;
    let v = 0;

    for (const e of model.electrodes) {
      if (e.type === "cuff") {
        const n = e.contacts ?? 8;
        for (let i = 0; i < n; i++) {
          const t = (i / n) * Math.PI * 2;
          const ex = model.nerve.cx + Math.cos(t) * e.r;
          const ey = model.nerve.cy + Math.sin(t) * e.r;
          const d = Math.hypot(x - ex, y - ey);
          v += amp * Math.exp(-d / fall);
        }
      } else {
        const d = Math.hypot(x - e.x, y - e.y);
        v += amp * Math.exp(-d / fall);
      }
    }

    return v;
  }

  function pickupWeight(distanceUm) {
    if (distanceUm <= PICKUP_STRONG_UM) return 1;
    if (distanceUm >= PICKUP_ZERO_UM) return 0;
    const t = (distanceUm - PICKUP_STRONG_UM) / (PICKUP_ZERO_UM - PICKUP_STRONG_UM);
    return 1 - t;
  }

  function activeRecordingElectrode() {
    // Prefer selected intra electrode; else first intra.
    const selected = model.electrodes.find((e) => e.id === model.selectedId && e.type === "intra");
    if (selected) return selected;
    return model.electrodes.find((e) => e.type === "intra") ?? null;
  }

  function pushRecEvent(t, amp) {
    model.recEvents.push({ t, amp: Math.max(0, Math.min(1, amp)) });

    // cleanup old events (keep a little extra padding)
    const start = t - 12;
    while (model.recEvents.length && model.recEvents[0].t < start) {
      model.recEvents.shift();
    }
  }

  function stepNoiseAndRecording(nowS) {
    const eRec = activeRecordingElectrode();
    const uPerPx = umPerPx();

    // Poisson noise firing for each axon
    // (This is the only O(N) part; keep N in a few thousand.)
    for (const a of model.axons) {
      if (nowS >= a.nextFire) {
        a.onUntil = Math.max(a.onUntil, nowS + ON_DWELL_S);

        // schedule next fire
        const exp = -Math.log(1 - rand()) * MEAN_ISI_S;
        a.nextFire = nowS + exp;

        // recording spike event if electrode exists
        if (eRec) {
          const dUm = Math.hypot(a.x - eRec.x, a.y - eRec.y) * uPerPx;
          const w = pickupWeight(dUm);
          if (w > 0) {
            // spikes are lines; amplitude is distance-weighted
            // Keep spikes sparse-ish by also gating small weights
            const amp = w * 0.9;
            pushRecEvent(nowS, amp);
          }
        }
      }
    }
  }

  function applyStimToAxons(nowMs) {
    // When pulsing, axons inside threshold are forced ON.
    const thr = Number(model.stim.thresh);
    const mult = stimMultiplier(nowMs);

    if (!model.pulse.active || mult === 0 || model.electrodes.length === 0) return;

    const nowS = nowMs / 1000;
    const stimHold = Math.max(STIM_DWELL_S, model.wave.durMs / 1000);

    for (const a of model.axons) {
      const v = Math.abs(fieldAt(a.x, a.y, mult));
      if (v >= thr) {
        a.stimUntil = Math.max(a.stimUntil, nowS + stimHold);
        a.onUntil = Math.max(a.onUntil, nowS + stimHold);
      }
    }

    // Big recording “event” for stimulation onset, if recording electrode exists
    if (activeRecordingElectrode()) {
      // Put a stronger spike at t0-ish (a visible marker)
      const tNow = nowS;
      pushRecEvent(tNow, 1.0);
    }
  }

  function drawRecording(nowS) {
    const W = rec.width;
    const H = rec.height;

    rctx.clearRect(0, 0, W, H);

    // background
    rctx.fillStyle = "rgba(255,255,255,0.10)";
    rctx.fillRect(0, 0, W, H);

    // axes / grid
    rctx.strokeStyle = "rgba(10,10,12,0.10)";
    rctx.lineWidth = 1;
    for (let i = 1; i < 6; i++) {
      const y = (i / 6) * H;
      rctx.beginPath();
      rctx.moveTo(0, y);
      rctx.lineTo(W, y);
      rctx.stroke();
    }

    const nowX = Math.floor(W * REC_NOW_X);

    // window start/end so that "now" sits at 75% width
    const pastS = REC_WINDOW_S * REC_NOW_X;
    const futureS = REC_WINDOW_S - pastS;

    const tStart = nowS - pastS;
    const tEnd = nowS + futureS;

    function tx(t) {
      return ((t - tStart) / (tEnd - tStart)) * W;
    }

    // baseline
    const mid = Math.floor(H * 0.65);
    rctx.strokeStyle = "rgba(10,10,12,0.25)";
    rctx.beginPath();
    rctx.moveTo(0, mid);
    rctx.lineTo(W, mid);
    rctx.stroke();

    // spikes
    rctx.strokeStyle = "rgba(10,10,12,0.85)";
    rctx.lineWidth = 2;

    for (const ev of model.recEvents) {
      if (ev.t < tStart || ev.t > tEnd) continue;
      const x = tx(ev.t);
      const ampPx = ev.amp * (H * 0.55);
      rctx.beginPath();
      rctx.moveTo(x, mid);
      rctx.lineTo(x, mid - ampPx);
      rctx.stroke();
    }

    // "now" marker at 75%
    rctx.strokeStyle = "rgba(0,0,0,0.35)";
    rctx.lineWidth = 2;
    rctx.beginPath();
    rctx.moveTo(nowX, 0);
    rctx.lineTo(nowX, H);
    rctx.stroke();

    rctx.fillStyle = "rgba(10,10,12,0.55)";
    rctx.font = "12px ui-sans-serif, system-ui";
    rctx.fillText("t = 0", nowX + 6, 14);
    rctx.fillText("10 s window", 10, 14);
  }

  function draw(nowMs = performance.now()) {
    const { cx, cy, r } = model.nerve;
    ctx.clearRect(0, 0, cnv.width, cnv.height);

    // paper-ish background
    ctx.fillStyle = "rgba(255,255,255,0.10)";
    ctx.fillRect(0, 0, cnv.width, cnv.height);

    const mult = stimMultiplier(nowMs);

    // world transform
    ctx.save();
    ctx.translate(model.view.ox, model.view.oy);
    ctx.scale(model.view.s, model.view.s);

    // field heatmap
    if (model.electrodes.length && mult !== 0) {
      const step = 18;
      let maxV = 0;
      const vals = [];
      for (let y = 0; y < cnv.height; y += step) {
        for (let x = 0; x < cnv.width; x += step) {
          const inside = Math.hypot(x - cx, y - cy) <= r;
          const v = inside ? Math.abs(fieldAt(x, y, mult)) : 0;
          vals.push({ x, y, v, inside });
          if (v > maxV) maxV = v;
        }
      }
      for (const p of vals) {
        if (!p.inside) continue;
        const a = maxV ? Math.min(0.22, (p.v / maxV) * 0.22) : 0;
        ctx.fillStyle = `rgba(20,20,22,${a})`;
        ctx.fillRect(p.x, p.y, step, step);
      }
    }

    // nerve boundary
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, Math.PI * 2);
    ctx.strokeStyle = "rgba(10,10,12,0.60)";
    ctx.lineWidth = 2;
    ctx.stroke();

    // fascicles
    for (const f of model.fascicles) {
      ctx.beginPath();
      ctx.arc(f.x, f.y, f.r, 0, Math.PI * 2);
      ctx.fillStyle = "rgba(255,255,255,0.14)";
      ctx.fill();
      ctx.strokeStyle = "rgba(10,10,12,0.20)";
      ctx.lineWidth = 1;
      ctx.stroke();
    }

    // axon sites as squares
    const nowS = nowMs / 1000;
    const cell = 2.2; // size of square pixel site (visual)
    const half = cell / 2;

    for (const a of model.axons) {
      const on = (a.onUntil > nowS) || (a.stimUntil > nowS);
      ctx.fillStyle = on ? "rgba(10,10,12,0.78)" : "rgba(10,10,12,0.12)";
      ctx.fillRect(a.x - half, a.y - half, cell, cell);
    }

    // electrodes
    for (const e of model.electrodes) {
      const selected = e.id === model.selectedId;
      if (e.type === "cuff") {
        ctx.beginPath();
        ctx.arc(cx, cy, e.r, 0, Math.PI * 2);
        ctx.strokeStyle = selected ? "rgba(10,10,12,0.95)" : "rgba(10,10,12,0.70)";
        ctx.lineWidth = selected ? 4 : 3;
        ctx.stroke();

        const n = e.contacts ?? 8;
        for (let i = 0; i < n; i++) {
          const t = (i / n) * Math.PI * 2;
          const x = cx + Math.cos(t) * e.r;
          const y = cy + Math.sin(t) * e.r;
          const glow = model.pulse.active ? Math.min(0.9, Math.abs(mult)) : 0;

          ctx.beginPath();
          ctx.arc(x, y, 3.4, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(10,10,12,${0.65 + glow * 0.3})`;
          ctx.fill();
          if (glow) {
            ctx.beginPath();
            ctx.arc(x, y, 11, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(10,10,12,${0.06 * glow})`;
            ctx.fill();
          }
        }
      } else {
        ctx.beginPath();
        ctx.arc(e.x, e.y, 6, 0, Math.PI * 2);
        ctx.fillStyle = selected ? "rgba(10,10,12,0.95)" : "rgba(10,10,12,0.78)";
        ctx.fill();
        ctx.beginPath();
        ctx.arc(e.x, e.y, 10, 0, Math.PI * 2);
        ctx.strokeStyle = "rgba(10,10,12,0.24)";
        ctx.lineWidth = 1;
        ctx.stroke();
      }
    }

    // label
    ctx.fillStyle = "rgba(10,10,12,0.62)";
    ctx.font = "16px Times New Roman";
    ctx.fillText("nerve", cx - 18, cy - r - 10);

    ctx.restore();

    // scale bar (screen space) — based on fixed 2mm
    const pxPerMm = ((model.nerve.r * 2) * model.view.s) / NERVE_DIAMETER_MM;
    const barMm = 1;
    const barPx = barMm * pxPerMm;

    const x0 = 18;
    const y0 = cnv.height - 18;
    ctx.strokeStyle = "rgba(10,10,12,0.55)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(x0, y0);
    ctx.lineTo(x0 + barPx, y0);
    ctx.stroke();

    ctx.fillStyle = "rgba(10,10,12,0.65)";
    ctx.font = "14px Times New Roman";
    ctx.fillText(`${barMm} mm`, x0, y0 - 6);

    // draw recording every frame
    drawRecording(nowS);

    // animation loop
    requestAnimationFrame(draw);
  }

  function rebuildAxonsFromUI() {
    const count = Math.round(Number(ui.axonCount.value));
    model.axons = buildAxonSites(model.nerve, model.fascicles, count);
    draw();
  }

  function syncStim() {
    model.stim.amp = Number(ui.stimAmp.value);
    model.stim.falloff = Number(ui.falloff.value);
    model.stim.thresh = Number(ui.thresh.value);
  }

  function syncWave() {
    model.wave.kind = ui.wave.value;
    model.wave.freqHz = Number(ui.freq.value);
    model.wave.pwMs = Number(ui.pw.value);
    model.wave.durMs = Number(ui.dur.value);
  }

  // Interaction (electrode drag + pan)
  let dragging = null;
  let panning = false;
  let dragOff = { x: 0, y: 0 };
  let pan0 = { x: 0, y: 0, ox: 0, oy: 0 };

  cnv.addEventListener("mousedown", (evt) => {
    const p = worldFromScreen(evt);
    const hit = hitTest(p.x, p.y);

    if (hit) {
      setSelected(hit.id);
      dragging = hit;
      if (hit.type === "intra") {
        dragOff.x = p.x - hit.x;
        dragOff.y = p.y - hit.y;
      }
      return;
    }

    setSelected(null);
    panning = true;
    pan0 = { x: evt.clientX, y: evt.clientY, ox: model.view.ox, oy: model.view.oy };
  });

  window.addEventListener("mousemove", (evt) => {
    if (dragging && dragging.type === "intra") {
      const p = worldFromScreen(evt);
      dragging.x = p.x - dragOff.x;
      dragging.y = p.y - dragOff.y;
      clampToNerve(dragging);
      setSelected(dragging.id);
      return;
    }

    if (panning) {
      const dx = evt.clientX - pan0.x;
      const dy = evt.clientY - pan0.y;
      model.view.ox = pan0.ox + dx;
      model.view.oy = pan0.oy + dy;
    }
  });

  window.addEventListener("mouseup", () => {
    dragging = null;
    panning = false;
  });

  cnv.addEventListener(
    "wheel",
    (evt) => {
      evt.preventDefault();
      const rect = cnv.getBoundingClientRect();
      const sx = ((evt.clientX - rect.left) / rect.width) * cnv.width;
      const sy = ((evt.clientY - rect.top) / rect.height) * cnv.height;

      const oldS = model.view.s;
      const dir = Math.sign(evt.deltaY);
      const factor = dir > 0 ? 0.92 : 1.08;
      const newS = Math.max(0.6, Math.min(4, oldS * factor));
      if (newS === oldS) return;

      const wx = (sx - model.view.ox) / oldS;
      const wy = (sy - model.view.oy) / oldS;

      model.view.s = newS;
      model.view.ox = sx - wx * newS;
      model.view.oy = sy - wy * newS;
    },
    { passive: false }
  );

  // Buttons
  ui.addCuff.addEventListener("click", () => {
    const e = { id: mkId(), type: "cuff", r: model.nerve.r * 1.02, contacts: 8 };
    model.electrodes.push(e);
    setSelected(e.id);
    toast("Added cuff");
  });

  ui.addIntra.addEventListener("click", () => {
    const e = { id: mkId(), type: "intra", x: model.nerve.cx + model.nerve.r * 0.12, y: model.nerve.cy };
    model.electrodes.push(e);
    setSelected(e.id);
    toast("Added intrafascicular (recording+stim)");
  });

  ui.reset.addEventListener("click", () => {
    model = defaultModel();
    syncUIFromModel();
    syncRangeMeta();
    toast("Reset");
  });

  ui.viewReset.addEventListener("click", () => {
    model.view = { s: 1, ox: 0, oy: 0 };
  });

  ui.pulse.addEventListener("click", () => {
    if (!model.electrodes.length) {
      toast("Add an electrode first");
      return;
    }
    syncWave();
    model.pulse.active = true;
    model.pulse.t0 = performance.now();
    toast("Pulsing");
  });

  ui.stop.addEventListener("click", () => {
    model.pulse.active = false;
    toast("Stopped");
  });

  // Export/import (kept minimal; axons regenerated from sliders)
  function exportModel() {
    const payload = {
      nerve: model.nerve,
      fascicles: model.fascicles,
      electrodes: model.electrodes,
      stim: model.stim,
      wave: model.wave,
      view: model.view,
      scale: { nerveDiameterMm: NERVE_DIAMETER_MM, axonCount: model.axons.length },
    };
    return JSON.stringify(payload, null, 2);
  }

  function importModel(txt) {
    const obj = JSON.parse(txt);
    if (!obj?.nerve || !obj?.fascicles || !obj?.electrodes) throw new Error("Invalid schema");

    model.nerve = obj.nerve;
    model.fascicles = obj.fascicles;
    model.electrodes = obj.electrodes;
    model.stim = obj.stim ?? model.stim;
    model.wave = obj.wave ?? model.wave;
    model.view = obj.view ?? model.view;

    const count = obj?.scale?.axonCount ?? Number(ui.axonCount.value);
    model.axons = buildAxonSites(model.nerve, model.fascicles, count);

    model.selectedId = null;
    model.pulse.active = false;
    model.recEvents = [];

    syncUIFromModel();
    syncRangeMeta();
    setSelected(null);
  }

  function openDialog(mode) {
    ui.dlgTitle.textContent = mode === "export" ? "Export JSON" : "Import JSON";
    ui.dlgText.value = mode === "export" ? exportModel() : "";
    ui.dlgApply.style.display = mode === "import" ? "inline-flex" : "none";
    ui.dlgCopy.style.display = mode === "export" ? "inline-flex" : "none";
    ui.dlg.showModal();
    ui.dlgText.focus();
    ui.dlgText.select();
  }

  ui.export.addEventListener("click", () => openDialog("export"));
  ui.import.addEventListener("click", () => openDialog("import"));

  ui.dlgCopy.addEventListener("click", async (e) => {
    e.preventDefault();
    await navigator.clipboard.writeText(ui.dlgText.value);
    toast("Copied");
  });

  ui.dlgApply.addEventListener("click", (e) => {
    e.preventDefault();
    try {
      importModel(ui.dlgText.value);
      ui.dlg.close();
      toast("Imported");
    } catch {
      toast("Import failed");
    }
  });

  // Wire inputs
  ui.axonCount.addEventListener("input", () => { rebuildAxonsFromUI(); syncRangeMeta(); });

  ui.stimAmp.addEventListener("input", () => { syncStim(); syncRangeMeta(); });
  ui.falloff.addEventListener("input", () => { syncStim(); syncRangeMeta(); });
  ui.thresh.addEventListener("input", () => { syncStim(); syncRangeMeta(); });

  ui.wave.addEventListener("change", syncWave);
  ui.freq.addEventListener("input", () => { syncWave(); syncRangeMeta(); });
  ui.pw.addEventListener("input", () => { syncWave(); syncRangeMeta(); });
  ui.dur.addEventListener("input", () => { syncWave(); syncRangeMeta(); });

  function syncUIFromModel() {
    ui.stimAmp.value = String(model.stim.amp);
    ui.falloff.value = String(model.stim.falloff);
    ui.thresh.value = String(model.stim.thresh ?? 55);

    ui.axonCount.value = String(model.axons.length);

    ui.wave.value = model.wave.kind;
    ui.freq.value = String(model.wave.freqHz);
    ui.pw.value = String(model.wave.pwMs);
    ui.dur.value = String(model.wave.durMs);
  }

  // --- Main loop: update noise + stim effects + draw ---
  function loop() {
    const nowMs = performance.now();
    const nowS = nowMs / 1000;

    // update noise
    stepNoiseAndRecording(nowS);

    // apply stim forcing
    applyStimToAxons(nowMs);

    requestAnimationFrame(loop);
  }

  // init
  syncUIFromModel();
  syncRangeMeta();
  syncStim();
  syncWave();
  setSelected(null);

  // Start rendering + simulation
  requestAnimationFrame(draw);
  requestAnimationFrame(loop);
</script>

<style>
  .simShell {
    display: grid;
    grid-template-columns: 340px 1fr;
    gap: 16px;
    align-items: start;
  }

  .panel {
    border: 1px solid rgba(10, 10, 12, 0.14);
    border-radius: 16px;
    background: rgba(255, 255, 255, 0.18);
    padding: 14px;
    position: sticky;
    top: 16px;
  }

  .panelSection {
    padding: 10px 8px;
    border-bottom: 1px solid rgba(10, 10, 12, 0.12);
  }
  .panelSection:last-child { border-bottom: none; }

  .panelTitle {
    font-weight: 700;
    font-size: 1.02em;
    margin-bottom: 10px;
    cursor: default;
  }

  details.panelSection > summary.panelTitle {
    list-style: none;
  }
  details.panelSection > summary.panelTitle::-webkit-details-marker { display: none; }

  .row {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
  }

  .btn {
    border: 1px solid rgba(10, 10, 12, 0.18);
    background: rgba(255, 255, 255, 0.30);
    border-radius: 999px;
    padding: 9px 12px;
    font-family: inherit;
    font-size: 0.95em;
    cursor: pointer;
  }
  .btn:hover {
    border-color: rgba(10, 10, 12, 0.32);
    background: rgba(255, 255, 255, 0.5);
    transform: translateY(-1px);
  }
  .btn.ghost { background: transparent; }

  .kv {
    display: flex;
    justify-content: space-between;
    gap: 12px;
    opacity: 0.9;
    margin: 6px 0;
    font-size: 0.95em;
  }

  .lab {
    display: grid;
    gap: 6px;
    margin-top: 10px;
    font-size: 0.95em;
  }

  .rangeRow {
    display: grid;
    gap: 6px;
  }

  .rangeMeta {
    display: flex;
    justify-content: space-between;
    align-items: baseline;
    font-size: 0.88em;
    opacity: 0.78;
  }

  .rangeMinMax {
    opacity: 0.8;
  }

  select {
    border: 1px solid rgba(10, 10, 12, 0.18);
    border-radius: 12px;
    background: rgba(255, 255, 255, 0.35);
    padding: 8px 10px;
    font-family: inherit;
  }

  input[type="range"] { width: 100%; }

  .muted {
    opacity: 0.74;
    line-height: 1.7;
    margin: 0;
  }

  .stage {
    border: 1px solid rgba(10, 10, 12, 0.14);
    border-radius: 16px;
    background: rgba(255, 255, 255, 0.12);
    overflow: hidden;
    position: relative;
  }

  .stageBar {
    display: flex;
    justify-content: space-between;
    gap: 12px;
    align-items: baseline;
    padding: 12px 14px;
    border-bottom: 1px solid rgba(10, 10, 12, 0.12);
    background: rgba(255, 255, 255, 0.10);
  }
  .stageTitle { font-weight: 700; }
  .stageHint { opacity: 0.7; font-size: 0.9em; }

  .stageBody {
    padding-bottom: 10px;
  }

  canvas {
    width: 100%;
    height: auto;
    display: block;
    cursor: grab;
  }
  canvas:active { cursor: grabbing; }

  .recBar {
    display: flex;
    justify-content: space-between;
    gap: 12px;
    align-items: baseline;
    padding: 10px 14px;
    border-top: 1px solid rgba(10, 10, 12, 0.10);
    border-bottom: 1px solid rgba(10, 10, 12, 0.10);
    background: rgba(255, 255, 255, 0.08);
  }
  .recTitle { font-weight: 700; }
  .recHint { opacity: 0.7; font-size: 0.88em; }

  .toast {
    position: absolute;
    bottom: 12px;
    right: 12px;
    padding: 10px 12px;
    border-radius: 999px;
    border: 1px solid rgba(10, 10, 12, 0.18);
    background: rgba(255, 255, 255, 0.6);
    font-size: 0.95em;
  }

  .dlg {
    border: 1px solid rgba(10, 10, 12, 0.24);
    border-radius: 16px;
    padding: 0;
    background: rgba(246, 241, 230, 0.98);
    color: inherit;
    width: min(900px, 92vw);
  }
  .dlg::backdrop { background: rgba(10, 10, 12, 0.35); }
  .dlgInner { padding: 14px; }

  .dlgHead {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 12px;
    margin-bottom: 10px;
  }
  .dlgTitle { font-weight: 700; font-size: 1.05em; }

  textarea {
    width: 100%;
    height: 320px;
    resize: vertical;
    border-radius: 12px;
    border: 1px solid rgba(10, 10, 12, 0.18);
    padding: 12px;
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    font-size: 13px;
    background: rgba(255, 255, 255, 0.55);
    color: rgba(10, 10, 12, 0.86);
  }

  .dlgActions {
    display: flex;
    justify-content: flex-end;
    gap: 10px;
    margin-top: 10px;
  }

  @media (max-width: 980px) {
    .simShell { grid-template-columns: 1fr; }
    .panel { position: relative; top: 0; }
  }
</style>
